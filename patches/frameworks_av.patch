From effb923ac029c90f60b44a8ba882260b96dee052 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Tue, 17 Dec 2013 13:15:52 +0700
Subject: [PATCH 1/9] OMXCodec: set default input buffer size

Broadcom OMX only set the buffer size to 65536 by default which
is not enough for higher bitrate video

(This patch has been adapted for Lollipop)

Change-Id: I74372f3d821e41feb38b9bc0cca4ef56aa019493
---
 media/libstagefright/ACodec.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 069325f..1986ec3 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -5831,6 +5831,16 @@ status_t ACodec::LoadedState::setupInputSurface() {
         mCodec->mInputFormat->setInt32(
                 "using-sw-read-often", !!(usageBits & GRALLOC_USAGE_SW_READ_OFTEN));
     }
+    // Capri's OMX fail to set a reasonable default size from width and height
+    else if (!strncmp(mComponentName.c_str(), "OMX.BRCM.vc4.decoder.", 21)) {
+        int32_t width;
+        int32_t height;
+        if (msg->findInt32("width", &width) && msg->findInt32("height", &height)) {
+            setMinBufferSize(kPortIndexInput, (width * height * 3) / 2);
+        } else {
+            ALOGE("Failed to set min buffer size");
+        }
+    }
 
     return OK;
 }
-- 
2.9.2


From 8164c10d579ae7fe5656243fbe3831883019ce2a Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Wed, 19 Nov 2014 20:33:58 +0700
Subject: [PATCH 2/9] ACodec: skip port index checking on vc4 encoder

Change-Id: I3fe742a8ec4b7f9bc0c4e5f0825fd3b88965a95e
---
 media/libstagefright/ACodec.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 1986ec3..b61ee15 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -4034,6 +4034,10 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
         return err;
     }
 
+    if (strncmp(mComponentName.c_str(), "OMX.BRCM.vc4.encoder.", 21) != 0)
+        // Skip checking on vc4 encoder. It will return the incorrect
+        // port index, but correct parameters.
+
     if (def.eDir != (portIndex == kPortIndexOutput ? OMX_DirOutput : OMX_DirInput)) {
         ALOGE("unexpected dir: %s(%d) on %s port", asString(def.eDir), def.eDir, niceIndex);
         return BAD_VALUE;
-- 
2.9.2


From e6dcdc83e1a239111f77df17102087cf35ba2766 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sun, 23 Nov 2014 17:27:20 +0700
Subject: [PATCH 3/9] ACodec: Don't trust provided width/height when setting
 input buffer size

They are bogus

Change-Id: I202b291a84d2f9a8c29aa2177ba52a0465f39deb
---
 media/libstagefright/ACodec.cpp | 10 +++-------
 1 file changed, 3 insertions(+), 7 deletions(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index b61ee15..8ca1479 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -5837,13 +5837,9 @@ status_t ACodec::LoadedState::setupInputSurface() {
     }
     // Capri's OMX fail to set a reasonable default size from width and height
     else if (!strncmp(mComponentName.c_str(), "OMX.BRCM.vc4.decoder.", 21)) {
-        int32_t width;
-        int32_t height;
-        if (msg->findInt32("width", &width) && msg->findInt32("height", &height)) {
-            setMinBufferSize(kPortIndexInput, (width * height * 3) / 2);
-        } else {
-            ALOGE("Failed to set min buffer size");
-        }
+        // We cannot trust the width/height from the message
+        // so just use 1920x1080
+        setMinBufferSize(kPortIndexInput, (1920 * 1080 * 3) / 2);
     }
 
     return OK;
-- 
2.9.2


From 6d456d498a23ac48e6f61bbcaad3b54e0d89e30c Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Fri, 28 Nov 2014 21:07:59 +0700
Subject: [PATCH 4/9] AudioFlinger: i9082: disable stereo record

Stereo record causes audio to speed up x2 for some reason.
Record in mono and let AudioFlinger resample to stereo
(we only have one mic anyway)

Change-Id: I59236addc022186fa35bd3b3914f42709c2318de
---
 services/audioflinger/AudioFlinger.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index b85b649..a926847 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -2057,6 +2057,10 @@ sp<AudioFlinger::RecordThread> AudioFlinger::openInput_l(audio_module_handle_t m
     audio_config_t halconfig = *config;
     audio_hw_device_t *inHwHal = inHwDev->hwDevice();
     audio_stream_in_t *inStream = NULL;
+
+    ALOGD("Forcing channel mask to mono on capri");
+    halconfig.channel_mask = AUDIO_CHANNEL_IN_MONO;
+
     status_t status = inHwHal->open_input_stream(inHwHal, *input, devices, &halconfig,
                                         &inStream, flags, address.string(), source);
     ALOGV("openInput_l() openInputStream returned input %p, SamplingRate %d"
-- 
2.9.2


From 8091a2695fe1c6553f86d0d16d97c5aa6c490224 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Wed, 10 Dec 2014 17:38:10 +0700
Subject: [PATCH 5/9] AudioFlinger: i9082: force audio to 48 KHz

Let surfaceflinger do all the resampling instead of the audio HAL

Don't know if it fixes anything, but worth a try

Change-Id: I0113831464f2f64c26a9c93bba8fe6b8229b09b4
---
 services/audioflinger/AudioFlinger.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index a926847..99e709c 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -2058,8 +2058,9 @@ sp<AudioFlinger::RecordThread> AudioFlinger::openInput_l(audio_module_handle_t m
     audio_hw_device_t *inHwHal = inHwDev->hwDevice();
     audio_stream_in_t *inStream = NULL;
 
-    ALOGD("Forcing channel mask to mono on capri");
+    ALOGD("Forcing input to mono 48K on capri");
     halconfig.channel_mask = AUDIO_CHANNEL_IN_MONO;
+    halconfig.sample_rate = 48000;
 
     status_t status = inHwHal->open_input_stream(inHwHal, *input, devices, &halconfig,
                                         &inStream, flags, address.string(), source);
-- 
2.9.2


From a7e9964bad75a7b1df5816b02efc6ed125d02dca Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Tue, 16 Dec 2014 21:12:22 +0700
Subject: [PATCH 6/9] stagefright: i9082: don't allocate too many extra buffers

Too many extra buffers (for a total of 8) causes random
video freezes and freezes on rotation

Change-Id: Idfe85f3cd77d6aa5422073857ceecec902e3ca68
---
 media/libstagefright/ACodec.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 8ca1479..18ef415 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -978,7 +978,7 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
     // 2. try to allocate two (2) additional buffers to reduce starvation from
     //    the consumer
     //    plus an extra buffer to account for incorrect minUndequeuedBufs
-    for (OMX_U32 extraBuffers = 2 + 1; /* condition inside loop */; extraBuffers--) {
+    for (OMX_U32 extraBuffers = 1; /* condition inside loop */; extraBuffers--) {
         OMX_U32 newBufferCount =
             def.nBufferCountMin + *minUndequeuedBuffers + extraBuffers;
         def.nBufferCountActual = newBufferCount;
-- 
2.9.2


From abc04ea332368f16bba3766530000a42d8c550cc Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sat, 20 Dec 2014 19:09:59 +0700
Subject: [PATCH 7/9] stagefright: i9082: fix for screen recording

Change-Id: Ib8a677eb1ecabc30efe163faa9b209f4db966437
---
 media/libstagefright/omx/GraphicBufferSource.cpp | 9 ---------
 media/libstagefright/omx/OMXNodeInstance.cpp     | 3 +++
 2 files changed, 3 insertions(+), 9 deletions(-)

diff --git a/media/libstagefright/omx/GraphicBufferSource.cpp b/media/libstagefright/omx/GraphicBufferSource.cpp
index 1a7dc9d..e257060 100644
--- a/media/libstagefright/omx/GraphicBufferSource.cpp
+++ b/media/libstagefright/omx/GraphicBufferSource.cpp
@@ -367,15 +367,6 @@ void GraphicBufferSource::codecBufferEmptied(OMX_BUFFERHEADERTYPE* header, int f
                         grallocMeta.pHandle, codecBuffer.mGraphicBuffer->handle);
                 CHECK(!"codecBufferEmptied: mismatched buffer");
             }
-        } else if (type == kMetadataBufferTypeANWBuffer
-                && header->nAllocLen >= sizeof(VideoNativeMetadata)) {
-            VideoNativeMetadata &nativeMeta = *(VideoNativeMetadata *)data;
-            if (nativeMeta.pBuffer != codecBuffer.mGraphicBuffer->getNativeBuffer()) {
-                // should never happen
-                ALOGE("codecBufferEmptied: buffer is %p, expected %p",
-                        nativeMeta.pBuffer, codecBuffer.mGraphicBuffer->getNativeBuffer());
-                CHECK(!"codecBufferEmptied: mismatched buffer");
-            }
         }
     }
 
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index da04737..d302fdc 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -881,10 +881,13 @@ status_t OMXNodeInstance::createGraphicBufferSource(
     }
 
     if (def.format.video.eColorFormat != OMX_COLOR_FormatAndroidOpaque) {
+        // VC Encoder change OMX_COLOR_FormatAndroidOpaque to 0x7F000005
+        if (def.format.video.eColorFormat != 0x7F000005) {
         CLOGW("createInputSurface requires COLOR_FormatSurface "
                 "(AndroidOpaque) color format instead of %s(%#x)",
                 asString(def.format.video.eColorFormat), def.format.video.eColorFormat);
         return INVALID_OPERATION;
+        }
     }
 
     uint32_t usageBits;
-- 
2.9.2


From e8c1f250bf550ab75bc666da72dd5760d67a57b6 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sun, 21 Dec 2014 15:25:33 +0700
Subject: [PATCH 8/9] stagefright: i9082: fix for miracast

Our encoder does not support OMX_Video_ControlRateConstant

Change-Id: I5f98f00406a6b28c1a2a1862fbcefa2fdd9055d6
---
 media/libstagefright/ACodec.cpp | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 18ef415..1952c37 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -3178,7 +3178,12 @@ static OMX_U32 setPFramesSpacing(int32_t iFramesInterval, int32_t frameRate) {
     return ret;
 }
 
-static OMX_VIDEO_CONTROLRATETYPE getBitrateMode(const sp<AMessage> &msg) {
+static OMX_VIDEO_CONTROLRATETYPE getBitrateMode(const sp<AMessage> &msg, const AString &name) {
+    // vc4 encoder only supports VBR
+    if (strncmp(name.c_str(), "OMX.BRCM.vc4.encoder.", 21) == 0) {
+        return OMX_Video_ControlRateVariable;
+    }
+
     int32_t tmp;
     if (!msg->findInt32("bitrate-mode", &tmp)) {
         return OMX_Video_ControlRateVariable;
@@ -3194,7 +3199,7 @@ status_t ACodec::setupMPEG4EncoderParameters(const sp<AMessage> &msg) {
         return INVALID_OPERATION;
     }
 
-    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg);
+    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg, mComponentName);
 
     float frameRate;
     if (!msg->findFloat("frame-rate", &frameRate)) {
@@ -3275,7 +3280,7 @@ status_t ACodec::setupH263EncoderParameters(const sp<AMessage> &msg) {
         return INVALID_OPERATION;
     }
 
-    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg);
+    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg, mComponentName);
 
     float frameRate;
     if (!msg->findFloat("frame-rate", &frameRate)) {
@@ -3403,7 +3408,7 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
         return INVALID_OPERATION;
     }
 
-    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg);
+    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg, mComponentName);
 
     float frameRate;
     if (!msg->findFloat("frame-rate", &frameRate)) {
@@ -3511,7 +3516,7 @@ status_t ACodec::setupHEVCEncoderParameters(const sp<AMessage> &msg) {
         return INVALID_OPERATION;
     }
 
-    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg);
+    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg, mComponentName);
 
     float frameRate;
     if (!msg->findFloat("frame-rate", &frameRate)) {
@@ -3578,7 +3583,7 @@ status_t ACodec::setupVPXEncoderParameters(const sp<AMessage> &msg) {
     }
     msg->findInt32("i-frame-interval", &iFrameInterval);
 
-    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg);
+    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg, mComponentName);
 
     float frameRate;
     if (!msg->findFloat("frame-rate", &frameRate)) {
-- 
2.9.2


From 4d7e99158f5375f33e470e92e0faa357179de284 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sun, 24 Jan 2016 12:38:26 +0700
Subject: [PATCH 9/9] AudioFlinger: i9082: fix getMicMute

Our audio driver sometimes return NO_INIT instead of NO_ERROR
for the get_mic_mute call. Prior to Marshmallow, this didn't cause
any issue because the return code was not checked.
---
 services/audioflinger/AudioFlinger.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 99e709c..b0dbbe5 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -839,6 +839,10 @@ bool AudioFlinger::getMicMute() const
     for (size_t i = 0; i < mAudioHwDevs.size(); i++) {
         audio_hw_device_t *dev = mAudioHwDevs.valueAt(i)->hwDevice();
         status_t result = dev->get_mic_mute(dev, &state);
+        // When not muted, Capri's audio driver incorrectly returns NO_INIT instead of NO_ERROR
+        if (mAudioHwDevs.valueAt(i) == mPrimaryHardwareDev && result == NO_INIT) {
+            result = NO_ERROR;
+        }
         if (result == NO_ERROR) {
             mute = mute && state;
         }
-- 
2.9.2

