--- a/bionic/libc/arch-arm/cortex-a9/bionic/memcpy_base.S
+++ b/bionic/libc/arch-arm/cortex-a9/bionic/memcpy_base.S
@@ -44,7 +44,7 @@
         /* check if buffers are aligned. If so, run arm-only version */
         eor         r3, r0, r1
         ands        r3, r3, #0x3
-        beq         __memcpy_base_aligned
+        beq         MEMCPY_BASE_ALIGNED
 
         /* Check the upper size limit for Neon unaligned memory access in memcpy */
         cmp         r2, #224
diff -ur a/external/icu/icu4c/source/common/ucnv.c b/external/icu/icu4c/source/common/ucnv.c
--- a/external/icu/icu4c/source/common/ucnv.c	2016-05-08 03:43:11.920995999 +0000
+++ b/external/icu/icu4c/source/common/ucnv.c	2016-05-08 03:34:25.212995999 +0000
@@ -2914,6 +2914,76 @@
             return FALSE;
     }
 }
+
+U_CAPI void    U_EXPORT2 ucnv_setToUCallBack_48 (UConverter * converter,
+                            UConverterToUCallback newAction,
+                            const void* newContext,
+                            UConverterToUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+  ucnv_setToUCallBack(converter, newAction, newContext,
+        oldAction, oldContext, err);
+}
+
+U_CAPI void  U_EXPORT2 ucnv_close_48 (UConverter * converter) {
+  ucnv_close (converter);
+}
+
+U_CAPI void  U_EXPORT2
+ucnv_setFromUCallBack_48 (UConverter * converter,
+                            UConverterFromUCallback newAction,
+                            const void* newContext,
+                            UConverterFromUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+
+  ucnv_setFromUCallBack(converter, newAction, newContext, oldAction,
+        oldContext, err);
+}
+
+U_CAPI void U_EXPORT2
+ucnv_convertEx_48 (UConverter *targetCnv, UConverter *sourceCnv,
+               char **target, const char *targetLimit,
+               const char **source, const char *sourceLimit,
+               UChar *pivotStart, UChar **pivotSource,
+               UChar **pivotTarget, const UChar *pivotLimit,
+               UBool reset, UBool flush,
+               UErrorCode *pErrorCode) {
+  ucnv_convertEx(targetCnv, sourceCnv, target, targetLimit, source,
+        sourceLimit, pivotStart, pivotSource,
+        pivotTarget, pivotLimit, reset, flush,
+        pErrorCode);
+}
+
+U_CAPI UConverter* U_EXPORT2
+ucnv_open_48 (const char *name,
+                       UErrorCode * err) {
+  return ucnv_open(name, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_FROM_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterFromUnicodeArgs *fromUArgs,
+                  const UChar* codeUnits,
+                  int32_t length,
+                  UChar32 codePoint,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_FROM_U_CALLBACK_STOP(context, fromUArgs, codeUnits,
+      length, codePoint, reason, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_TO_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterToUnicodeArgs *toUArgs,
+                  const char* codeUnits,
+                  int32_t length,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_TO_U_CALLBACK_STOP(context, toUArgs, codeUnits, length,
+      reason, err);
+}
+
 #endif
 
 /*
diff -ur a/frameworks/av/include/media/stagefright/ColorConverter.h b/frameworks/av/include/media/stagefright/ColorConverter.h
--- a/frameworks/av/include/media/stagefright/ColorConverter.h	2016-05-08 03:43:37.008995999 +0000
+++ b/frameworks/av/include/media/stagefright/ColorConverter.h	2016-05-08 03:34:25.216995999 +0000
@@ -67,6 +67,9 @@
     status_t convertCbYCrY(
             const BitmapParams &src, const BitmapParams &dst);
 
+    status_t convertYCbYCr(
+            const BitmapParams &src, const BitmapParams &dst);
+
     status_t convertYUV420Planar(
             const BitmapParams &src, const BitmapParams &dst);
 
diff -ur a/frameworks/av/media/libstagefright/ACodec.cpp b/frameworks/av/media/libstagefright/ACodec.cpp
--- a/frameworks/av/media/libstagefright/ACodec.cpp	2016-05-08 03:43:37.076995999 +0000
+++ b/frameworks/av/media/libstagefright/ACodec.cpp	2016-05-08 03:34:25.216995999 +0000
@@ -778,6 +778,7 @@
 }
 
 status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
+    ALOGE("ACodec:PATCH:allocateBuffersOnPort portIndex(%i)", portIndex);
     CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);
 
     CHECK(mDealer[portIndex] == NULL);
@@ -785,20 +786,21 @@
 
     status_t err;
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        if (storingMetadataInDecodedBuffers()) {
-            err = allocateOutputMetadataBuffers();
-        } else {
+            ALOGE("ACodec:PATCH:allocateBuffersOnPort portIndex(%i) -> allocateOutputBuffersFromNativeWindow()", portIndex);
             err = allocateOutputBuffersFromNativeWindow();
-        }
     } else {
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort ELSE (%i)", portIndex);
         OMX_PARAM_PORTDEFINITIONTYPE def;
         InitOMXParams(&def);
         def.nPortIndex = portIndex;
 
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort ELSE def.nPortIndex(%i) portIndex(%i)", def.nPortIndex, portIndex);
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort getParameter(OMX_IndexParamPortDefinition) (%i) (%i)", def.nPortIndex, portIndex);
         err = mOMX->getParameter(
                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
         if (err == OK) {
+            ALOGE("ACodec:PATCH:allocateBuffersOnPort getParameter(OMX_IndexParamPortDefinition) OK (%i) (%i)", def.nPortIndex, portIndex);
             MetadataBufferType type =
                 portIndex == kPortIndexOutput ? mOutputMetadataType : mInputMetadataType;
             int32_t bufSize = def.nBufferSize;
@@ -866,9 +868,11 @@
                 mBuffers[portIndex].push(info);
             }
         }
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort getParameter(OMX_IndexParamPortDefinition) ERROR? (%i) (%i)", def.nPortIndex, portIndex);
     }
 
     if (err != OK) {
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort ERROR (%i)", portIndex);
         return err;
     }
 
@@ -876,6 +880,7 @@
     notify->setInt32("what", CodecBase::kWhatBuffersAllocated);
 
     notify->setInt32("portIndex", portIndex);
+    ALOGE("ACodec:PATCH:allocateBuffersOnPort setInt32(portIndex)(%i)", portIndex);
 
     sp<PortDescription> desc = new PortDescription;
 
@@ -893,14 +898,17 @@
 
 status_t ACodec::setupNativeWindowSizeFormatAndUsage(
         ANativeWindow *nativeWindow /* nonnull */, int *finalUsage /* nonnull */) {
+    ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s]", mComponentName.c_str());
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
+    ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.nPortIndex = %i", mComponentName.c_str(), def.nPortIndex);
 
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
     if (err != OK) {
+        ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] getParameter(OMX_IndexParamPortDefinition) ERROR", mComponentName.c_str());
         return err;
     }
 
@@ -925,6 +933,20 @@
     setNativeWindowColorFormat(eNativeColorFormat);
 #endif
 
+    ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat(%i)", mComponentName.c_str(), def.format.video.eColorFormat);
+    OMX_COLOR_FORMATTYPE HalColorFormat;
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatYCbYCr:{
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+            ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat NOW (%i)", mComponentName.c_str(), def.format.video.eColorFormat);
+        }
+        break;
+        default:
+            ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat Default (%i) (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12", mComponentName.c_str(), (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+    }
+
     ALOGV("gralloc usage: %#x(OMX) => %#x(ACodec)", omxUsage, usage);
     int32_t width = 0, height = 0;
     int32_t isAdaptivePlayback = 0;
@@ -947,7 +969,7 @@
 #ifdef USE_SAMSUNG_COLORFORMAT
             eNativeColorFormat,
 #else
-            def.format.video.eColorFormat,
+            HalColorFormat,
 #endif
             mRotationDegrees,
             usage);
@@ -976,6 +998,7 @@
 status_t ACodec::configureOutputBuffersFromNativeWindow(
         OMX_U32 *bufferCount, OMX_U32 *bufferSize,
         OMX_U32 *minUndequeuedBuffers) {
+    ALOGE("ACodec:PATCH:configureOutputBuffersFromNativeWindow[%s]", mComponentName.c_str());
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
@@ -987,6 +1010,7 @@
         err = setupNativeWindowSizeFormatAndUsage(mNativeWindow.get(), &mNativeWindowUsageBits);
     }
     if (err != OK) {
+        ALOGE("ACodec:PATCH:configureOutputBuffersFromNativeWindow[%s] getParameter(OMX_IndexParamPortDefinition) ERROR", mComponentName.c_str());
         mNativeWindowUsageBits = 0;
         return err;
     }
@@ -1709,8 +1733,10 @@
 
 status_t ACodec::configureCodec(
         const char *mime, const sp<AMessage> &msg) {
+    ALOGE("ACodec:PATCH:configureCodec[%s]", mComponentName.c_str());
     int32_t encoder;
     if (!msg->findInt32("encoder", &encoder)) {
+        ALOGE("ACodec:PATCH:configureCodec[%s] not encoder", mComponentName.c_str());
         encoder = false;
     }
 
@@ -1725,6 +1751,7 @@
     status_t err = setComponentRole(encoder /* isEncoder */, mime);
 
     if (err != OK) {
+        ALOGE("ACodec:PATCH:configureCodec[%s] setComponentRole ERROR", mComponentName.c_str());
         return err;
     }
 
@@ -1741,6 +1768,7 @@
     if (encoder
             && msg->findInt32("store-metadata-in-buffers", &storeMeta)
             && storeMeta != 0) {
+        ALOGE("ACodec:PATCH:configureCodec[%s] storeMetaDataInBuffers", mComponentName.c_str());
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE, &mInputMetadataType);
         if (err != OK) {
             ALOGE("[%s] storeMetaDataInBuffers (input) failed w/ err %d",
@@ -1751,16 +1779,11 @@
         // For this specific case we could be using camera source even if storeMetaDataInBuffers
         // returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.
         if (mInputMetadataType == kMetadataBufferTypeGrallocSource) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] mInputMetadataType == kMetadataBufferTypeGrallocSource", mComponentName.c_str());
             mInputMetadataType = kMetadataBufferTypeCameraSource;
         }
 
-        uint32_t usageBits;
-        if (mOMX->getParameter(
-                mNode, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,
-                &usageBits, sizeof(usageBits)) == OK) {
-            inputFormat->setInt32(
-                    "using-sw-read-often", !!(usageBits & GRALLOC_USAGE_SW_READ_OFTEN));
-        }
+        ALOGE("ACodec:PATCH:configureCodec[%s] BEGIN using-sw-read-often", mComponentName.c_str());
     }
 
     int32_t prependSPSPPS = 0;
@@ -1768,6 +1791,7 @@
             && msg->findInt32("prepend-sps-pps-to-idr-frames", &prependSPSPPS)
             && prependSPSPPS != 0) {
         OMX_INDEXTYPE index;
+        ALOGE("ACodec:PATCH:configureCodec[%s] getExtensionIndex OMX.google.android.index.prependSPSPPSToIDRFrames", mComponentName.c_str());
         err = mOMX->getExtensionIndex(
                 mNode,
                 "OMX.google.android.index.prependSPSPPSToIDRFrames",
@@ -1799,7 +1823,7 @@
         OMX_BOOL enable = (OMX_BOOL) (prependSPSPPS
             && msg->findInt32("store-metadata-in-buffers-output", &storeMeta)
             && storeMeta != 0);
-
+        ALOGE("ACodec:PATCH:configureCodec[%s] storeMetaDataInBuffers 2", mComponentName.c_str());
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexOutput, enable, &mOutputMetadataType);
         if (err != OK) {
             ALOGE("[%s] storeMetaDataInBuffers (output) failed w/ err %d",
@@ -1809,28 +1833,33 @@
         if (!msg->findInt64(
                     "repeat-previous-frame-after",
                     &mRepeatFrameDelayUs)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] repeat-previous-frame-after ERROR", mComponentName.c_str());
             mRepeatFrameDelayUs = -1ll;
         }
 
         if (!msg->findInt64("max-pts-gap-to-encoder", &mMaxPtsGapUs)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] max-pts-gap-to-encoder ERROR", mComponentName.c_str());
             mMaxPtsGapUs = -1ll;
         }
 
         if (!msg->findFloat("max-fps-to-encoder", &mMaxFps)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] max-fps-to-encoder ERROR", mComponentName.c_str());
             mMaxFps = -1;
         }
 
         if (!msg->findInt64("time-lapse", &mTimePerCaptureUs)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] time-lapse ERROR", mComponentName.c_str());
             mTimePerCaptureUs = -1ll;
         }
 
         if (!msg->findInt32(
                     "create-input-buffers-suspended",
                     (int32_t*)&mCreateInputBuffersSuspended)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] create-input-buffers-suspended false", mComponentName.c_str());
             mCreateInputBuffersSuspended = false;
         }
     }
-
+    ALOGE("ACodec:PATCH:configureCodec[%s] 2", mComponentName.c_str());
     // NOTE: we only use native window for video decoders
     sp<RefBase> obj;
     bool haveNativeWindow = msg->findObject("native-window", &obj)
@@ -1852,7 +1881,7 @@
     if (haveNativeWindow) {
         sp<ANativeWindow> nativeWindow =
             static_cast<ANativeWindow *>(static_cast<Surface *>(obj.get()));
-
+        ALOGE("ACodec:PATCH:configureCodec[%s] 3", mComponentName.c_str());
         // START of temporary support for automatic FRC - THIS WILL BE REMOVED
         int32_t autoFrc;
         if (msg->findInt32("auto-frc", &autoFrc)) {
@@ -1870,13 +1899,13 @@
             }
         }
         // END of temporary support for automatic FRC
-
+        ALOGE("ACodec:PATCH:configureCodec[%s] 4", mComponentName.c_str());
         int32_t tunneled;
         if (msg->findInt32("feature-tunneled-playback", &tunneled) &&
             tunneled != 0) {
             ALOGI("Configuring TUNNELED video playback.");
             mTunneled = true;
-
+            ALOGE("ACodec:PATCH:configureCodec[%s] 5", mComponentName.c_str());
             int32_t audioHwSync = 0;
             if (!msg->findInt32("audio-hw-sync", &audioHwSync)) {
                 ALOGW("No Audio HW Sync provided for video tunnel");
@@ -1900,12 +1929,14 @@
                     // allow failure
                     err = OK;
                 } else {
+                    ALOGE("ACodec:PATCH:configureCodec[%s] 6", mComponentName.c_str());
                     inputFormat->setInt32("max-width", maxWidth);
                     inputFormat->setInt32("max-height", maxHeight);
                     inputFormat->setInt32("adaptive-playback", true);
                 }
             }
         } else {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 7", mComponentName.c_str());
             ALOGV("Configuring CPU controlled video playback.");
             mTunneled = false;
 
@@ -1919,6 +1950,7 @@
             }
 
             // Always try to enable dynamic output buffers on native surface
+            ALOGE("ACodec:PATCH:configureCodec[%s] 8", mComponentName.c_str());
             err = mOMX->storeMetaDataInBuffers(
                     mNode, kPortIndexOutput, OMX_TRUE, &mOutputMetadataType);
             if (err != OK) {
@@ -1968,8 +2000,10 @@
                     }
                 }
                 // allow failure
+                ALOGE("ACodec:PATCH:configureCodec[%s] 9", mComponentName.c_str());
                 err = OK;
             } else {
+                ALOGE("ACodec:PATCH:configureCodec[%s] 10", mComponentName.c_str());
                 ALOGV("[%s] storeMetaDataInBuffers succeeded",
                         mComponentName.c_str());
                 CHECK(storingMetadataInDecodedBuffers());
@@ -1980,6 +2014,7 @@
             }
 
             int32_t push;
+            ALOGE("ACodec:PATCH:configureCodec[%s] 11", mComponentName.c_str());
             if (msg->findInt32("push-blank-buffers-on-shutdown", &push)
                     && push != 0) {
                 mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;
@@ -1993,6 +2028,7 @@
         }
 
         int32_t rotationDegrees;
+        ALOGE("ACodec:PATCH:configureCodec[%s] 12", mComponentName.c_str());
         if (msg->findInt32("rotation-degrees", &rotationDegrees)) {
             mRotationDegrees = rotationDegrees;
         } else {
@@ -2001,6 +2037,7 @@
     }
 
     if (video) {
+        ALOGE("ACodec:PATCH:configureCodec[%s] 13", mComponentName.c_str());
         // determine need for software renderer
         bool usingSwRenderer = false;
         if (haveNativeWindow && (mComponentName.startsWith("OMX.google.") ||
@@ -2010,28 +2047,35 @@
         }
 
         if (encoder) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 14", mComponentName.c_str());
             err = setupVideoEncoder(mime, msg);
         } else {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 15", mComponentName.c_str());
             err = setupVideoDecoder(mime, msg, haveNativeWindow);
         }
 
         if (err != OK) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 16", mComponentName.c_str());
             return err;
         }
 
         if (haveNativeWindow) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 17", mComponentName.c_str());
             mNativeWindow = static_cast<Surface *>(obj.get());
         }
 
         // initialize native window now to get actual output format
         // TODO: this is needed for some encoders even though they don't use native window
         err = initNativeWindow();
+        ALOGE("ACodec:PATCH:configureCodec[%s] 18", mComponentName.c_str());
         if (err != OK) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 19", mComponentName.c_str());
             return err;
         }
 
         // fallback for devices that do not handle flex-YUV for native buffers
         if (haveNativeWindow) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 20", mComponentName.c_str());
             int32_t requestedColorFormat = OMX_COLOR_FormatUnused;
             if (msg->findInt32("color-format", &requestedColorFormat) &&
                     requestedColorFormat == OMX_COLOR_FormatYUV420Flexible) {
@@ -2079,6 +2123,7 @@
         }
 
         if (usingSwRenderer) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 21", mComponentName.c_str());
             outputFormat->setInt32("using-sw-renderer", 1);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
@@ -2268,20 +2313,23 @@
         err = setMinBufferSize(kPortIndexInput, 8192);  // XXX
     }
 
-    int32_t priority;
-    if (msg->findInt32("priority", &priority)) {
-        err = setPriority(priority);
-    }
+    ALOGE("ACodec:PATCH:configureCodec[%s] skip setPriority", mComponentName.c_str());
 
-    int32_t rateInt = -1;
-    float rateFloat = -1;
-    if (!msg->findFloat("operating-rate", &rateFloat)) {
-        msg->findInt32("operating-rate", &rateInt);
-        rateFloat = (float)rateInt;  // 16MHz (FLINTMAX) is OK for upper bound.
-    }
-    if (rateFloat > 0) {
-        err = setOperatingRate(rateFloat, video);
-    }
+    //int32_t priority;
+    //if (msg->findInt32("priority", &priority)) {
+    //    err = setPriority(priority);
+    //}
+
+    ALOGE("ACodec:PATCH:configureCodec[%s] skip setOperatingRate", mComponentName.c_str());
+    //int32_t rateInt = -1;
+    //float rateFloat = -1;
+    //if (!msg->findFloat("operating-rate", &rateFloat)) {
+    //    msg->findInt32("operating-rate", &rateInt);
+    //    rateFloat = (float)rateInt;  // 16MHz (FLINTMAX) is OK for upper bound.
+    //}
+    //if (rateFloat > 0) {
+    //    err = setOperatingRate(rateFloat, video);
+    //}
 
     mBaseOutputFormat = outputFormat;
 
@@ -2819,6 +2867,7 @@
         OMX_VIDEO_CODINGTYPE compressionFormat,
         OMX_COLOR_FORMATTYPE colorFormat,
         bool usingNativeBuffers) {
+    ALOGE("ACodec:PATCH:setVideoPortFormatType[%s]", mComponentName.c_str());
     OMX_VIDEO_PARAM_PORTFORMATTYPE format;
     InitOMXParams(&format);
     format.nPortIndex = portIndex;
@@ -2828,11 +2877,13 @@
     OMX_U32 index = 0;
     for (;;) {
         format.nIndex = index;
+        ALOGE("ACodec:PATCH:setVideoPortFormatType[%s] getParameter(OMX_IndexParamVideoPortFormat)", mComponentName.c_str());
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
 
         if (err != OK) {
+            ALOGE("ACodec:PATCH:setVideoPortFormatType[%s] getParameter(OMX_IndexParamVideoPortFormat) ERROR", mComponentName.c_str());
             return err;
         }
 
@@ -2842,7 +2893,7 @@
                 && isFlexibleColorFormat(
                         mOMX, mNode, format.eColorFormat, usingNativeBuffers, &flexibleEquivalent)
                 && colorFormat == flexibleEquivalent) {
-            ALOGI("[%s] using color format %#x in place of %#x",
+            ALOGE("[%s] using color format %#x in place of %#x",
                     mComponentName.c_str(), format.eColorFormat, colorFormat);
             colorFormat = format.eColorFormat;
         }
@@ -2875,6 +2926,7 @@
     }
 
     if (!found) {
+        ALOGE("ACodec:PATCH:setVideoPortFormatType[%s] UNKNOWN_ERROR", mComponentName.c_str());
         return UNKNOWN_ERROR;
     }
 
@@ -2900,6 +2952,7 @@
 // For legacy support, we prefer a standard format, but will settle for a SW readable
 // flex-YUV format.
 status_t ACodec::setSupportedOutputFormat(bool getLegacyFlexibleFormat) {
+    ALOGE("ACodec:PATCH:setSupportedOutputFormat[%s]", mComponentName.c_str());
     OMX_VIDEO_PARAM_PORTFORMATTYPE format, legacyFormat;
     InitOMXParams(&format);
     format.nPortIndex = kPortIndexOutput;
@@ -2910,10 +2963,12 @@
 
     for (OMX_U32 index = 0; ; ++index) {
         format.nIndex = index;
+        ALOGE("ACodec:PATCH:setSupportedOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat)", mComponentName.c_str());
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
         if (err != OK) {
+            ALOGE("ACodec:PATCH:setSupportedOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat) ERROR", mComponentName.c_str());
             // no more formats, pick legacy format if found
             if (legacyFormat.eColorFormat != OMX_COLOR_FormatUnused) {
                  memcpy(&format, &legacyFormat, sizeof(format));
@@ -2945,6 +3000,7 @@
             memcpy(&legacyFormat, &format, sizeof(format));
         }
     }
+    ALOGE("ACodec:PATCH:setSupportedOutputFormat[%s] setParameter(OMX_IndexParamVideoPortFormat)", mComponentName.c_str());
     return mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
@@ -2998,6 +3054,7 @@
 
 status_t ACodec::setupVideoDecoder(
         const char *mime, const sp<AMessage> &msg, bool haveNativeWindow) {
+    ALOGE("ACodec:PATCH:setupVideoDecoder[%s]", mComponentName.c_str());
     int32_t width, height;
     if (!msg->findInt32("width", &width)
             || !msg->findInt32("height", &height)) {
@@ -3025,11 +3082,15 @@
     if (msg->findInt32("color-format", &tmp)) {
         OMX_COLOR_FORMATTYPE colorFormat =
             static_cast<OMX_COLOR_FORMATTYPE>(tmp);
+
+        ALOGE("ACodec:PATCH:setupVideoDecoder[%s] colorFormat = %i", mComponentName.c_str(), colorFormat);
+
         err = setVideoPortFormatType(
                 kPortIndexOutput, OMX_VIDEO_CodingUnused, colorFormat, haveNativeWindow);
         if (err != OK) {
             ALOGW("[%s] does not support color format %d",
                   mComponentName.c_str(), colorFormat);
+            ALOGE("ACodec:PATCH:setupVideoDecoder[%s] setSupportedOutputFormat", mComponentName.c_str());
             err = setSupportedOutputFormat(!haveNativeWindow /* getLegacyFlexibleFormat */);
         }
     } else {
@@ -3067,6 +3128,7 @@
 }
 
 status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
+    ALOGE("ACodec:PATCH:setupVideoEncoder");
     int32_t tmp;
     if (!msg->findInt32("color-format", &tmp)) {
         return INVALID_OPERATION;
@@ -3075,6 +3137,8 @@
     OMX_COLOR_FORMATTYPE colorFormat =
         static_cast<OMX_COLOR_FORMATTYPE>(tmp);
 
+    ALOGE("ACodec:PATCH:setupVideoEncoder colorFormat = %i", colorFormat);
+
     status_t err = setVideoPortFormatType(
             kPortIndexInput, OMX_VIDEO_CodingUnused, colorFormat);
 
@@ -3231,7 +3295,7 @@
     }
 
     if (err == OK) {
-        ALOGI("setupVideoEncoder succeeded");
+        ALOGE("setupVideoEncoder succeeded");
     }
 
     return err;
@@ -3757,6 +3821,7 @@
 
 status_t ACodec::verifySupportForProfileAndLevel(
         int32_t profile, int32_t level) {
+    ALOGE("ACodec:PATCH:verifySupportForProfileAndLevel[%s] profile[%i] level[%i]", mComponentName.c_str(), profile, level);
     OMX_VIDEO_PARAM_PROFILELEVELTYPE params;
     InitOMXParams(&params);
     params.nPortIndex = kPortIndexOutput;
@@ -3769,6 +3834,7 @@
                 sizeof(params));
 
         if (err != OK) {
+            ALOGE("ACodec:PATCH:verifySupportForProfileAndLevel[%s] getParameter(OMX_IndexParamVideoProfileLevelQuerySupported) ERROR", mComponentName.c_str());
             return err;
         }
 
@@ -3831,15 +3897,18 @@
         OMX_U32 portIndex,
         int32_t width, int32_t height, OMX_VIDEO_CODINGTYPE compressionFormat,
         float frameRate) {
+    ALOGE("ACodec:PATCH:setVideoFormatOnPort");
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
 
     OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
 
+    ALOGE("ACodec:PATCH:setVideoFormatOnPort getParameter(OMX_IndexParamPortDefinition)");
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     if (err != OK) {
+        ALOGE("ACodec:PATCH:setVideoFormatOnPort getParameter(OMX_IndexParamPortDefinition) ERROR");
         return err;
     }
 
@@ -3867,6 +3936,7 @@
         }
     }
 
+    ALOGE("ACodec:PATCH:setVideoFormatOnPort setParameter(OMX_IndexParamPortDefinition)");
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -3962,6 +4032,7 @@
 
 // static
 bool ACodec::describeDefaultColorFormat(DescribeColorFormatParams &params) {
+    ALOGE("ACodec:PATCH:describeDefaultColorFormat");
     MediaImage &image = params.sMediaImage;
     memset(&image, 0, sizeof(image));
 
@@ -3969,6 +4040,20 @@
     image.mNumPlanes = 0;
 
     const OMX_COLOR_FORMATTYPE fmt = params.eColorFormat;
+
+    ALOGE("ACodec:PATCH:describeDefaultColorFormat eColorFormat = %i", params.eColorFormat);
+
+    switch(params.eColorFormat){
+        case OMX_COLOR_FormatYCbYCr:{
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat eColorFormat = %i SET to %i", params.eColorFormat, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            params.eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        }
+        break;
+        default:
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat default eColorFormat = %i", params.eColorFormat);
+        break;
+    }
+
     image.mWidth = params.nFrameWidth;
     image.mHeight = params.nFrameHeight;
 
@@ -4009,7 +4094,9 @@
 
     switch ((int)fmt) {
         case HAL_PIXEL_FORMAT_YV12:
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat case HAL_PIXEL_FORMAT_YV12 (%i)", HAL_PIXEL_FORMAT_YV12);
             if (params.bUsingNativeBuffers) {
+                ALOGE("ACodec:PATCH:describeDefaultColorFormat case HAL_PIXEL_FORMAT_YV12 (%i) bUsingNativeBuffers", HAL_PIXEL_FORMAT_YV12);
                 size_t ystride = align(params.nStride, 16);
                 size_t cstride = align(params.nStride / 2, 16);
                 image.mPlane[image.Y].mRowInc = ystride;
@@ -4028,11 +4115,13 @@
                 image.mPlane[image.U].mVertSubsampling = 2;
                 break;
             } else {
+                ALOGE("ACodec:PATCH:describeDefaultColorFormat case HAL_PIXEL_FORMAT_YV12 (%i) ERROR", HAL_PIXEL_FORMAT_YV12);
                 // fall through as YV12 is used for YUV420Planar by some codecs
             }
 
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatYUV420PackedPlanar:
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat case OMX_COLOR_FormatYUV420Planar (%i) or OMX_COLOR_FormatYUV420PackedPlanar (%i)", OMX_COLOR_FormatYUV420Planar, OMX_COLOR_FormatYUV420PackedPlanar);
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
             image.mPlane[image.U].mColInc = 1;
             image.mPlane[image.U].mRowInc = params.nStride / 2;
@@ -4051,6 +4140,7 @@
             // FIXME: NV21 for sw-encoder, NV12 for decoder and hw-encoder
         case OMX_COLOR_FormatYUV420PackedSemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat case OMX_COLOR_FormatYUV420SemiPlanar (%i) or OMX_COLOR_FormatYUV420PackedSemiPlanar (%i) or OMX_TI_COLOR_FormatYUV420PackedSemiPlanar (%i)", OMX_COLOR_FormatYUV420SemiPlanar, OMX_COLOR_FormatYUV420PackedSemiPlanar, OMX_TI_COLOR_FormatYUV420PackedSemiPlanar);
             // NV12
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
             image.mPlane[image.U].mColInc = 2;
@@ -4076,6 +4166,7 @@
         const sp<IOMX> &omx, IOMX::node_id node,
         DescribeColorFormatParams &describeParams)
 {
+    ALOGE("ACodec:PATCH:describeColorFormat");
     OMX_INDEXTYPE describeColorFormatIndex;
     if (omx->getExtensionIndex(
             node, "OMX.google.android.index.describeColorFormat",
@@ -4085,6 +4176,7 @@
             &describeParams, sizeof(describeParams)) != OK) {
         return describeDefaultColorFormat(describeParams);
     }
+    ALOGE("ACodec:PATCH:describeColorFormat MediaImage::MEDIA_IMAGE_TYPE_UNKNOWN");
     return describeParams.sMediaImage.mType !=
             MediaImage::MEDIA_IMAGE_TYPE_UNKNOWN;
 }
@@ -4133,13 +4225,16 @@
 }
 
 status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
+    ALOGE("ACodec:PATCH:getPortFormat[%s]", mComponentName.c_str());
     const char *niceIndex = portIndex == kPortIndexInput ? "input" : "output";
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
 
+    ALOGE("ACodec:PATCH:getPortFormat[%s] getParameter(OMX_IndexParamPortDefinition)", mComponentName.c_str());
     status_t err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     if (err != OK) {
+        ALOGE("ACodec:PATCH:getPortFormat[%s] getParameter(OMX_IndexParamPortDefinition) ERROR", mComponentName.c_str());
         return err;
     }
 
@@ -5864,8 +5959,10 @@
     AString mime;
 
     if (!msg->findString("mime", &mime)) {
+        ALOGE("ACodec:PATCH:onConfigureComponent MIME BAD_VALUE");
         err = BAD_VALUE;
     } else {
+        ALOGE("ACodec:PATCH:onConfigureComponent configureCodec [%s]", mCodec->mComponentName.c_str());
         err = mCodec->configureCodec(mime.c_str(), msg);
     }
     if (err != OK) {
@@ -5933,6 +6030,7 @@
             observer->setNotificationMessage(notify);
             mCodec->mComponentName = componentName;
 
+            ALOGE("ACodec:PATCH:onConfigureComponent configureCodec2 [%s]", mCodec->mComponentName.c_str());
             err = mCodec->configureCodec(mime.c_str(), msg);
         }
 
@@ -6585,14 +6683,15 @@
         }
     }
 
-    float rate;
-    if (params->findFloat("operating-rate", &rate) && rate > 0) {
-        status_t err = setOperatingRate(rate, mIsVideo);
-        if (err != OK) {
-            ALOGE("Failed to set parameter 'operating-rate' (err %d)", err);
-            return err;
-        }
-    }
+    ALOGE("ACodec:PATCH:setParameters skip operating-rate");
+    //float rate;
+    //if (params->findFloat("operating-rate", &rate) && rate > 0) {
+    //    status_t err = setOperatingRate(rate, mIsVideo);
+    //    if (err != OK) {
+    //        ALOGE("Failed to set parameter 'operating-rate' (err %d)", err);
+    //        return err;
+    //    }
+    //}
 
     return OK;
 }
diff -ur a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
--- a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-05-08 03:43:37.284995999 +0000
+++ b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-05-08 03:34:25.216995999 +0000
@@ -44,6 +44,7 @@
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
+        case OMX_COLOR_FormatYCbYCr:
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
@@ -110,6 +111,10 @@
             err = convertCbYCrY(src, dst);
             break;
 
+        case OMX_COLOR_FormatYCbYCr:
+            err = convertYCbYCr(src, dst);
+            break;
+
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
             err = convertQCOMYUV420SemiPlanar(src, dst);
             break;
@@ -159,6 +164,71 @@
 
             signed u_b = u * 517;
             signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            if (x + 1 < src.cropWidth()) {
+                *(uint32_t *)(&dst_ptr[x]) = (rgb2 << 16) | rgb1;
+            } else {
+                dst_ptr[x] = rgb1;
+            }
+        }
+
+        src_ptr += src.mWidth * 2;
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
+status_t ColorConverter::convertYCbYCr(
+        const BitmapParams &src, const BitmapParams &dst) {
+        ALOGE("PATCH:ColorConverter:convertYCbYCr");
+    // XXX Untested
+
+    uint8_t *kAdjustedClip = initClip();
+
+    if (!((src.mCropLeft & 1) == 0
+        && src.cropWidth() == dst.cropWidth()
+        && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint16_t *dst_ptr = (uint16_t *)dst.mBits
+        + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+
+    const uint8_t *src_ptr = (const uint8_t *)src.mBits
+        + (src.mCropTop * dst.mWidth + src.mCropLeft) * 2;
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x += 2) {
+            signed y1 = (signed)src_ptr[2 * x ] - 16;
+            signed y2 = (signed)src_ptr[2 * x + 2] - 16;
+            signed u = (signed)src_ptr[2 * x + 1] - 128;  
+            signed v = (signed)src_ptr[2 * x + 3] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
             signed v_g = -v * 208;
             signed v_r = v * 409;
 
--- a/frameworks/av/media/libstagefright/MediaBufferGroup.cpp    2016-05-27 06:16:16.461305200 +0000
+++ b/frameworks/av/media/libstagefright/MediaBufferGroup.cpp    2016-02-27 08:15:52.000000000 +0000
@@ -55,6 +55,13 @@
     mLastBuffer = buffer;
 }
 
+#ifdef ADD_LEGACY_ACQUIRE_BUFFER_SYMBOL
+extern "C" status_t _ZN7android16MediaBufferGroup14acquire_bufferEPPNS_11MediaBufferE(
+    MediaBufferGroup* group, MediaBuffer **out) {
+    return group->acquire_buffer(out, false);
+}
+#endif
+
 status_t MediaBufferGroup::acquire_buffer(
         MediaBuffer **out, bool nonBlocking) {
     Mutex::Autolock autoLock(mLock);
diff -ur a/frameworks/av/media/libstagefright/MPEG4Writer.cpp b/frameworks/av/media/libstagefright/MPEG4Writer.cpp
--- a/frameworks/av/media/libstagefright/MPEG4Writer.cpp	2016-05-08 03:43:37.084995999 +0000
+++ b/frameworks/av/media/libstagefright/MPEG4Writer.cpp	2016-05-08 03:38:34.524995999 +0000
@@ -2216,6 +2216,7 @@
 }
 
 status_t MPEG4Writer::Track::threadEntry() {
+    ALOGE("MPEG4Writer:PATCH:threadEntry");
     int32_t count = 0;
     const int64_t interleaveDurationUs = mOwner->interleaveDuration();
     const bool hasMultipleTracks = (mOwner->numTracks() > 1);
@@ -2243,6 +2244,7 @@
     }
 
     if (mOwner->isRealTimeRecording()) {
+        ALOGE("MPEG4Writer:PATCH:threadEntry ANDROID_PRIORITY_AUDIO");
         androidSetThreadPriority(0, ANDROID_PRIORITY_AUDIO);
     }
 
@@ -2370,8 +2372,7 @@
 
         timestampUs -= previousPausedDurationUs;
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+            ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 1");
         }
 
         if (!mIsAudio) {
@@ -2386,8 +2387,7 @@
             cttsOffsetTimeUs =
                     timestampUs - decodingTimeUs;
             if (WARN_UNLESS(kMaxCttsOffsetTimeUs >= decodingTimeUs - timestampUs, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 2");
             }
 
             timestampUs = decodingTimeUs;
@@ -2398,8 +2398,7 @@
             currCttsOffsetTimeTicks =
                     (cttsOffsetTimeUs * mTimeScale + 500000LL) / 1000000LL;
             if (WARN_UNLESS(currCttsOffsetTimeTicks <= 0x0FFFFFFFFLL, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 3");
             }
 
             if (mStszTableEntries->count() == 0) {
@@ -2440,8 +2439,7 @@
         }
 
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+            ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 4");
         }
 
         ALOGV("%s media time stamp: %" PRId64 " and previous paused duration %" PRId64,
@@ -2461,10 +2459,7 @@
         if (currDurationTicks < 0ll) {
             ALOGE("timestampUs %" PRId64 " < lastTimestampUs %" PRId64 " for %s track",
                 timestampUs, lastTimestampUs, trackName);
-            copy->release();
-            err = UNKNOWN_ERROR;
-            mSource->notifyError(err);
-            return err;
+            ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 5");
         }
 
         // if the duration is different for this sample, see if it is close enough to the previous
@@ -2562,7 +2557,7 @@
     }
 
     if (isTrackMalFormed()) {
-        err = ERROR_MALFORMED;
+        ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 6");
     }
 
     mOwner->trackProgressStatus(mTrackId, -1, err);
diff -ur a/frameworks/av/media/libstagefright/omx/GraphicBufferSource.cpp b/frameworks/av/media/libstagefright/omx/GraphicBufferSource.cpp
--- a/frameworks/av/media/libstagefright/omx/GraphicBufferSource.cpp	2016-05-08 03:43:37.296995999 +0000
+++ b/frameworks/av/media/libstagefright/omx/GraphicBufferSource.cpp	2016-05-08 03:34:25.224995999 +0000
@@ -369,6 +369,7 @@
             }
         } else if (type == kMetadataBufferTypeANWBuffer
                 && header->nAllocLen >= sizeof(VideoNativeMetadata)) {
+#ifndef HAWAII_HWC
             VideoNativeMetadata &nativeMeta = *(VideoNativeMetadata *)data;
             if (nativeMeta.pBuffer != codecBuffer.mGraphicBuffer->getNativeBuffer()) {
                 // should never happen
@@ -376,6 +377,7 @@
                         nativeMeta.pBuffer, codecBuffer.mGraphicBuffer->getNativeBuffer());
                 CHECK(!"codecBufferEmptied: mismatched buffer");
             }
+#endif
         }
     }
 
diff -ur a/frameworks/av/media/libstagefright/OMXCodec.cpp b/frameworks/av/media/libstagefright/OMXCodec.cpp
--- a/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-05-08 03:43:37.088995999 +0000
+++ b/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-05-08 03:34:25.220995999 +0000
@@ -347,7 +347,7 @@
                 InstantiateSoftwareEncoder(componentName, source, meta);
 
             if (softwareCodec != NULL) {
-                ALOGV("Successfully allocated software codec '%s'", componentName);
+                ALOGE("Successfully allocated software codec '%s'", componentName);
 
                 return softwareCodec;
             }
@@ -372,7 +372,7 @@
 
         status_t err = omx->allocateNode(componentName, observer, &node);
         if (err == OK) {
-            ALOGV("Successfully allocated OMX node '%s'", componentName);
+            ALOGE("Successfully allocated OMX node '%s'", componentName);
 
             sp<OMXCodec> codec = new OMXCodec(
                     omx, node, quirks, flags,
@@ -527,7 +527,7 @@
 }
 
 status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
-    ALOGV("configureCodec protected=%d",
+    ALOGE("configureCodec protected=%d",
          (mFlags & kEnableGrallocUsageProtected) ? 1 : 0);
 
     if (!(mFlags & kIgnoreCodecSpecificData)) {
@@ -758,6 +758,7 @@
         OMX_U32 portIndex,
         OMX_VIDEO_CODINGTYPE compressionFormat,
         OMX_COLOR_FORMATTYPE colorFormat) {
+    ALOGE("OMXCodec:PATCH:setVideoPortFormatType");
     OMX_VIDEO_PARAM_PORTFORMATTYPE format;
     InitOMXParams(&format);
     format.nPortIndex = portIndex;
@@ -767,11 +768,13 @@
     OMX_U32 index = 0;
     for (;;) {
         format.nIndex = index;
+        ALOGE("OMXCodec:PATCH:setVideoPortFormatType getParameter(OMX_IndexParamVideoPortFormat)");
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
 
         if (err != OK) {
+            ALOGE("OMXCodec:PATCH:setVideoPortFormatType getParameter(OMX_IndexParamVideoPortFormat) ERROR");
             return err;
         }
 
@@ -794,11 +797,13 @@
         if (index >= kMaxColorFormatSupported) {
             CODEC_LOGE("color format %d or compression format %d is not supported",
                 colorFormat, compressionFormat);
+            ALOGE("OMXCodec:PATCH:setVideoPortFormatType UNKNOWN_ERROR");
             return UNKNOWN_ERROR;
         }
     }
 
     if (!found) {
+        ALOGE("OMXCodec:PATCH:setVideoPortFormatType UNKNOWN_ERROR 2");
         return UNKNOWN_ERROR;
     }
 
@@ -841,11 +846,13 @@
 status_t OMXCodec::findTargetColorFormat(
         const sp<MetaData>& meta, OMX_COLOR_FORMATTYPE *colorFormat) {
     ALOGV("findTargetColorFormat");
+    ALOGE("OMXCodec:PATCH:findTargetColorFormat");
     CHECK(mIsEncoder);
 
     *colorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
     int32_t targetColorFormat;
     if (meta->findInt32(kKeyColorFormat, &targetColorFormat)) {
+        ALOGE("OMXCodec:PATCH:findTargetColorFormat %i", (OMX_COLOR_FORMATTYPE) targetColorFormat);
         *colorFormat = (OMX_COLOR_FORMATTYPE) targetColorFormat;
     }
 
@@ -855,6 +862,7 @@
 
 status_t OMXCodec::isColorFormatSupported(
         OMX_COLOR_FORMATTYPE colorFormat, int portIndex) {
+    ALOGE("OMXCodec:PATCH:isColorFormatSupported %i", colorFormat);
     ALOGV("isColorFormatSupported: %d", static_cast<int>(colorFormat));
 
     // Enumerate all the color formats supported by
@@ -866,6 +874,7 @@
     OMX_U32 index = 0;
     portFormat.nIndex = index;
     while (true) {
+        ALOGE("OMXCodec:PATCH:isColorFormatSupported %i getParameter(OMX_IndexParamVideoPortFormat)", colorFormat);
         if (OMX_ErrorNone != mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &portFormat, sizeof(portFormat))) {
@@ -874,7 +883,9 @@
         // Make sure that omx component does not overwrite
         // the incremented index (bug 2897413).
         CHECK_EQ(index, portFormat.nIndex);
+        ALOGE("OMXCodec:PATCH:isColorFormatSupported %i BUT IN CODEC %i)", colorFormat, portFormat.eColorFormat);
         if (portFormat.eColorFormat == colorFormat) {
+            ALOGE("OMXCodec:PATCH:isColorFormatSupported %i FOUND %i)", colorFormat, portFormat.eColorFormat);
             CODEC_LOGV("Found supported color format: %d", portFormat.eColorFormat);
             return OK;  // colorFormat is supported!
         }
@@ -894,6 +905,7 @@
 void OMXCodec::setVideoInputFormat(
         const char *mime, const sp<MetaData>& meta) {
 
+    ALOGE("OMXCodec:PATCH:setVideoInputFormat");
     int32_t width, height, frameRate, bitRate, stride, sliceHeight;
     bool success = meta->findInt32(kKeyWidth, &width);
     success = success && meta->findInt32(kKeyHeight, &height);
@@ -1216,6 +1228,7 @@
 }
 
 status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
+    ALOGE("OMXCodec:PATCH:setupAVCEncoderParameters");
     int32_t iFramesInterval, frameRate, bitRate;
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
@@ -1292,12 +1305,13 @@
 status_t OMXCodec::setVideoOutputFormat(
         const char *mime, const sp<MetaData>& meta) {
 
+    ALOGE("OMXCodec:PATCH:setVideoOutputFormat");
     int32_t width, height;
     bool success = meta->findInt32(kKeyWidth, &width);
     success = success && meta->findInt32(kKeyHeight, &height);
     CHECK(success);
 
-    CODEC_LOGV("setVideoOutputFormat width=%d, height=%d", width, height);
+    CODEC_LOGE("setVideoOutputFormat width=%d, height=%d", width, height);
 
     OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
@@ -1324,6 +1338,7 @@
             kPortIndexInput, compressionFormat, OMX_COLOR_FormatUnused);
 
     if (err != OK) {
+        ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] setVideoPortFormatType ERROR", mComponentName);
         return err;
     }
 
@@ -1341,6 +1356,12 @@
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
         int32_t colorFormat;
+
+        if (!strncmp("OMX.brcm.video.h264.hw.decoder", mComponentName, 30)) {
+            ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] colorFormat BRCM set 19", mComponentName);
+            format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+        }
+        
         if (meta->findInt32(kKeyColorFormat, &colorFormat)
                 && colorFormat != OMX_COLOR_FormatUnused
                 && colorFormat != format.eColorFormat) {
@@ -1353,6 +1374,10 @@
                 if (format.eColorFormat == colorFormat) {
                     break;
                 }
+                if((unsigned int)err == 0x80001005){
+                    ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat) colorFormat(%i) != format.eColorFormat (%i) OMX_ErrorNoMore", mComponentName, colorFormat, format.eColorFormat);
+                    err = OMX_ErrorNoMore;
+                }
             }
             if (format.eColorFormat != colorFormat) {
                 CODEC_LOGE("Color format %d is not supported", colorFormat);
@@ -1841,11 +1866,32 @@
 #endif
     }
 
+    ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow def.format.video.eColorFormat = %i", def.format.video.eColorFormat);
+
+    OMX_COLOR_FORMATTYPE HalColorFormat;
+    status_t errss;
+    
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatYCbYCr:
+            ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> (%i)", OMX_COLOR_FormatYCbYCr, OMX_COLOR_FormatYUV420Planar);
+            def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        case OMX_COLOR_FormatYUV420Planar:
+            ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYUV420Planar(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYUV420Planar, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        default:
+            ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow default(%i) -> default(%i)", def.format.video.eColorFormat, def.format.video.eColorFormat);
+            HalColorFormat = def.format.video.eColorFormat;
+        break;
+    }
+
     err = setNativeWindowSizeFormatAndUsage(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat,
+            HalColorFormat,
             rotationDegrees,
             usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
     if (err != 0) {
@@ -4502,7 +4548,13 @@
                     caps->mColorFormats.push(flexibleEquivalent);
                 }
             }
-            caps->mColorFormats.push(portFormat.eColorFormat);
+            if(portFormat.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+                ALOGE("PATCH:OMXCodec:QueryCodec:getParameter(IndexParamVideoPortFormat) portFormat.eColorFormat %i SET %i", portFormat.eColorFormat, OMX_COLOR_FormatYUV420Planar);
+                caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
+            }else{
+                ALOGE("PATCH:OMXCodec:QueryCodec:getParameter(IndexParamVideoPortFormat) DEFAULT portFormat.eColorFormat %i", portFormat.eColorFormat);
+                caps->mColorFormats.push(portFormat.eColorFormat);
+            }
         }
     }
     
     
--- a/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -886,10 +886,17 @@ status_t OMXNodeInstance::createGraphicBufferSource(
     }
 
     if (def.format.video.eColorFormat != OMX_COLOR_FormatAndroidOpaque) {
+#ifdef HAWAII_HWC
+        // VC Encoder change OMX_COLOR_FormatAndroidOpaque to 0x7F000005
+        if (def.format.video.eColorFormat != 0x7F000005) {
+#endif
         CLOGW("createInputSurface requires COLOR_FormatSurface "
                 "(AndroidOpaque) color format instead of %s(%#x)",
                 asString(def.format.video.eColorFormat), def.format.video.eColorFormat);
         return INVALID_OPERATION;
+#ifdef HAWAII_HWC
+        }
+#endif
     }
 
     uint32_t usageBits;
--- a/frameworks/base/core/jni/AndroidRuntime.cpp
+++ b/frameworks/base/core/jni/AndroidRuntime.cpp
@@ -698,6 +698,11 @@
     if (strcmp(propBuf, "true") == 0) {
       addOption("-XX:LowMemoryMode");
     }
+    
+property_get("ro.optimize.bcm", propBuf, "");
+    if (strcmp(propBuf, "true") == 0) {
+      addOption("-XX:LowMemoryMode");
+    }    
 
     parseRuntimeOption("dalvik.vm.gctype", gctypeOptsBuf, "-Xgc:");
     parseRuntimeOption("dalvik.vm.backgroundgctype", backgroundgcOptsBuf, "-XX:BackgroundGC=");